\section{Conclusion} \label{sec:conclusion}
%\subsection{Summary}
In this work, the original code base which included rendering and reconstruction capabilities was developed further into the first version of the \gls{sispo} software package. Furthermore, \gls{sispo} was extended to include an image compression and decompression package.

\Gls{sispo} was used to simulate several fly-by scenarios with \gls{sssb} sizes of \SI{1}{\kilo\meter} and \SI{10}{\kilo\meter} and fly-by distances of \SI{50}{\kilo\meter}, \SI{100}{\kilo\meter}, \SI{200}{\kilo\meter} and \SI{400}{\kilo\meter}.

Comparison with real images from asteroid Bennu and comets \gls{67p} and \gls{81p} show that the current shader implementation creates imagery mostly resembling an asteroid rather than a comet. Differences between rendered images and real comet images include missing gas and dust jets as well as ridge-like surfaces features.

Rendered images are compressed with either \gls{png} or \gls{jp2} representing lossless and lossy compression techniques respectively. Lossy compression reduces the amount of data more than lossless compression at the cost of introducing artefacts. Lossy compression with low compression ratios introduces artefacts which resemble random noise. Artefacts introduced by high compression ratios show correlation to surface features. Visual inspection confirms that low compression ratios do not degrade specific parts of an image in contrast to high compression ratios which blur contours of surface features.

Compressed images are used to reconstruct a \gls{3d} model leveraging \gls{sfm} algorithms provided by \gls{omvg} and \gls{omvs}. Two incremental and one global \gls{sfm} algorithm were used during simulations. In total, the IncrementalSfM2 algorithm reconstructed the most points in most scenarios. Well-defined scenes were better reconstructed with the IncrementalSfM algorithm while less well-defined scenes were better reconstructed with IncrementalSfM2. The incremental \gls{sfm} approach is more successful in \gls{sispo} since the GlobalSfM algorithm reconstructs more points than IncrementalSfM and IncrementalSfM2 in only one scenario. A \gls{3d} model could successfully be reconstructed in all tested cases except for a \SI{400}{\kilo\meter} fly-by of a \SI{1}{\kilo\meter} \gls{sssb} with highest lossy compression ratio. The number of reconstructed points ranged from $\approx \SI{2e3}{}$~points for a \SI{400}{\kilo\meter} fly-by of a \SI{1}{\kilo\meter} \gls{sssb} to $\approx \SI{6e6}{}$~points for a \SI{50}{\kilo\meter} fly-by of a \SI{10}{\kilo\meter} \gls{sssb}. It was found that lossy compression introduces artefacts that can increase the number of reconstructed points from the \gls{sfm} algorithms if the artefacts are distributed randomly. High lossy compression ratios alter surface features which might lead to an increased point count in the point cloud. However, such points are often outliers since the points are removed when creating a \gls{3d} mesh from the point cloud.

For fly-by scenarios with \SI{1}{\kilo\meter} \glspl{sssb}, lossy compression allows data reduction to about half of the data size of lossless compression. 

Problems were found during rendering and reconstruction. One rendering problem are stripes, dark patches across the entire \gls{sssb}, which were found on many images of a \SI{10}{\kilo\meter} \gls{sssb}. Rendering fireflies are another problem that was encountered. Fireflies  were only found in one image of a \SI{50}{\kilo\meter} fly-by of a \SI{10}{\kilo\meter} nucleus. Both problems could not be resolved in this work.

Reconstruction problems included inverted \gls{3d} models and surfaces not being closed. Both problems were overcome by removing optimisation of intrinsic camera parameters and using priors. Removing the optimisation is justified with the assumption of known calibration values for imagers in space missions. Motion priors, i.e. initial guesses for extrinsic camera parameters, are used since it is assumed that a rough trajectory of spacecraft is known from other measurements.

\Gls{sispo} can aid in designing missions to \glspl{sssb}. The \textit{HERA} and \textit{\gls{ci}} missions target a \gls{sssb} with a mother spacecraft carrying a number of small satellites. Therefore, investigating the effect of compression is a first step in maximising the useful scientific image data that can be transmitted from these small spacecraft. Mission concepts like \textit{\gls{mantis}}, \textit{CASTAway} or \textit{\gls{mat}} could use \gls{sispo} to improve their design and maximising their science return. Additionally, \gls{sispo} can be used for developing optical navigation algorithms. Either indirectly by creating a large number of images or directly by utilising the camera pose estimates provided by the \gls{sfm} pipeline.

%\subsection{Future Developments}
While providing a foundation for \gls{sispo}, several issues could not be addressed in the course of this work. First, a realistic model of spacecraft attitude motion and control is missing. The camera of the simulation environment is perfectly oriented to the centre of the \gls{sssb} in \gls{sispo}. Realistic rotation should cover at least two effects, motion blur due to instantaneous rotation velocities of spacecraft and off-centre pointing due to control inaccuracies. Furthermore, it is necessary to include imaging distortions such as astigmatism, bokeh, coma, field curvature, glare.

Moreover, it is necessary to include a gas and dust environment around the \gls{sssb} to extend rendering capabilities from asteroids to comets. Including multiple \glspl{sssb} into the simulation environment would allow more complex simulation scenarios including  for example a binary system. Furthermore, a more recent and accurate star catalogue, like the GAIA catalogue, could be implemented to improve star map rendering.

Currently, \gls{sispo} assumes that an instrument always uses \gls{rgb} channels. Since many imagers used in deep space use monochrome \glspl{ccd}, an option to select either \gls{rgb} or monochrome rendering should be implemented. Furthermore, the realism of rendered images can be increased by using an improved photometric system, such as the \gls{ubvri} \cite{Bessell1993PhotometricSystems}, that takes into account the sensitivity of \glspl{ccd} in the red and infrared spectrum.

A simulation of data transmission should be included. For example, a realistic simulation for packet loss using common radio transmission methods and protocols. Additionally, compression techniques which are commonly used in deep space missions should be added to increase the realism in \gls{sispo}. Effects of non-optimal lighting conditions, i.e. overexposure and underexposure, on compression should be investigated. A substantial part of images far from a \gls{sssb} is black which could be cropped away to reduce the amount of data. Consequently, image cropping should be added to increase the realism of image compression and data transmission. The ultimate goal, e.g. for the \textit{\gls{ci}} mission, would be to develop a prioritisation algorithm for the images which can prioritise data transmission on packet level.

Furthermore, the shader that implements the procedural terrain generation should be developed further. The shader should represent a comet's surface better, e.g. by including ridge-like surfaces features. Since most of the execution time of \gls{sispo} is used for rendering, the shader should be developed to be less computationally heavy. Additionally, the \textit{SssbConstDist} is currently rendered in each time step. However, the \textit{SssbConstDist} image is only required for calibration for long distances from the nucleus. Rendering performance can be improved by checking the apparent size of the \gls{sssb} in the \textit{SssbOnly} image directly after rendering to decide whether it is necessary to render the \textit{SssbConstDist} image.  The interface for it should be included into \gls{sispo} and restricted to values that create reasonable images.

An attempt to include a Hapke model via the synthspace package\footnote{\url{https://github.com/oknuutti/synthspace}} was unsuccessful in this work. It would be interesting to compare the results of \gls{sispo} and the Hapke model to show strengths and weaknesses of both models. Moreover, a Hapke model is substantially faster while being less accurate. One possible use case would be creating real-time imagery which is currently not possible with \gls{sispo}.